# coding: utf-8

"""
    Utools_twitter_tools_api

    X (Twitter) API for search, Tweets, users, followers, images, media and more. Supports some v1.1 and v2 API endpoints, with more to come in the future!  # noqa: E501

    OpenAPI spec version: 1.1
    Contact: huojiecs@gmail.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class TwitterGetTweesApiToolsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def favoriters_v2_using_get(self, api_key, tweet_id, **kwargs):  # noqa: E501
        """Favoriters by V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.favoriters_v2_using_get(api_key, tweet_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str tweet_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.favoriters_v2_using_get_with_http_info(api_key, tweet_id, **kwargs)  # noqa: E501
        else:
            (data) = self.favoriters_v2_using_get_with_http_info(api_key, tweet_id, **kwargs)  # noqa: E501
            return data

    def favoriters_v2_using_get_with_http_info(self, api_key, tweet_id, **kwargs):  # noqa: E501
        """Favoriters by V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.favoriters_v2_using_get_with_http_info(api_key, tweet_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str tweet_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'tweet_id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method favoriters_v2_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `favoriters_v2_using_get`")  # noqa: E501
        # verify the required parameter 'tweet_id' is set
        if self.api_client.client_side_validation and ('tweet_id' not in params or
                                                       params['tweet_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `tweet_id` when calling `favoriters_v2_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'tweet_id' in params:
            query_params.append(('tweetId', params['tweet_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/favoritersV2', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def favoriters_v2_using_post(self, api_key, tweet_id, **kwargs):  # noqa: E501
        """Favoriters by V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.favoriters_v2_using_post(api_key, tweet_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str tweet_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.favoriters_v2_using_post_with_http_info(api_key, tweet_id, **kwargs)  # noqa: E501
        else:
            (data) = self.favoriters_v2_using_post_with_http_info(api_key, tweet_id, **kwargs)  # noqa: E501
            return data

    def favoriters_v2_using_post_with_http_info(self, api_key, tweet_id, **kwargs):  # noqa: E501
        """Favoriters by V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.favoriters_v2_using_post_with_http_info(api_key, tweet_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str tweet_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'tweet_id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method favoriters_v2_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `favoriters_v2_using_post`")  # noqa: E501
        # verify the required parameter 'tweet_id' is set
        if self.api_client.client_side_validation and ('tweet_id' not in params or
                                                       params['tweet_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `tweet_id` when calling `favoriters_v2_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'tweet_id' in params:
            query_params.append(('tweetId', params['tweet_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/favoritersV2', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def favorites_list_using_get(self, api_key, user_id, **kwargs):  # noqa: E501
        """favorites are now known as likes.  # noqa: E501

        See details https://developer.twitter.com/en/docs/twitter-api/v1/tweets/post-and-engage/api-reference/get-favorites-list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.favorites_list_using_get(api_key, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str user_id: (required)
        :param str max_id: Returns results with an ID less than (that is, older than) or equal to the specified ID.
        :param str screen_name:
        :param str since_id: Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available.
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.favorites_list_using_get_with_http_info(api_key, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.favorites_list_using_get_with_http_info(api_key, user_id, **kwargs)  # noqa: E501
            return data

    def favorites_list_using_get_with_http_info(self, api_key, user_id, **kwargs):  # noqa: E501
        """favorites are now known as likes.  # noqa: E501

        See details https://developer.twitter.com/en/docs/twitter-api/v1/tweets/post-and-engage/api-reference/get-favorites-list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.favorites_list_using_get_with_http_info(api_key, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str user_id: (required)
        :param str max_id: Returns results with an ID less than (that is, older than) or equal to the specified ID.
        :param str screen_name:
        :param str since_id: Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available.
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'user_id', 'max_id', 'screen_name', 'since_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method favorites_list_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `favorites_list_using_get`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `favorites_list_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'max_id' in params:
            query_params.append(('maxId', params['max_id']))  # noqa: E501
        if 'screen_name' in params:
            query_params.append(('screenName', params['screen_name']))  # noqa: E501
        if 'since_id' in params:
            query_params.append(('sinceId', params['since_id']))  # noqa: E501
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/favoritesList', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def favorites_list_using_post(self, api_key, user_id, **kwargs):  # noqa: E501
        """favorites are now known as likes.  # noqa: E501

        See details https://developer.twitter.com/en/docs/twitter-api/v1/tweets/post-and-engage/api-reference/get-favorites-list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.favorites_list_using_post(api_key, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str user_id: (required)
        :param str max_id: Returns results with an ID less than (that is, older than) or equal to the specified ID.
        :param str screen_name:
        :param str since_id: Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available.
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.favorites_list_using_post_with_http_info(api_key, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.favorites_list_using_post_with_http_info(api_key, user_id, **kwargs)  # noqa: E501
            return data

    def favorites_list_using_post_with_http_info(self, api_key, user_id, **kwargs):  # noqa: E501
        """favorites are now known as likes.  # noqa: E501

        See details https://developer.twitter.com/en/docs/twitter-api/v1/tweets/post-and-engage/api-reference/get-favorites-list  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.favorites_list_using_post_with_http_info(api_key, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str user_id: (required)
        :param str max_id: Returns results with an ID less than (that is, older than) or equal to the specified ID.
        :param str screen_name:
        :param str since_id: Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available.
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'user_id', 'max_id', 'screen_name', 'since_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method favorites_list_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `favorites_list_using_post`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `favorites_list_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'max_id' in params:
            query_params.append(('maxId', params['max_id']))  # noqa: E501
        if 'screen_name' in params:
            query_params.append(('screenName', params['screen_name']))  # noqa: E501
        if 'since_id' in params:
            query_params.append(('sinceId', params['since_id']))  # noqa: E501
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/favoritesList', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mentions_timeline_using_get(self, api_key, auth_token, ct0, **kwargs):  # noqa: E501
        """get mentionsTimeline Detail  # noqa: E501

        See details  https://developer.twitter.com/en/docs/twitter-api/v1/tweets/timelines/api-reference/get-statuses-mentions_timeline  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mentions_timeline_using_get(api_key, auth_token, ct0, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str auth_token: (required)
        :param str ct0: (required)
        :param str include_entities:
        :param str max_id: Returns results with an ID less than (that is, older than) or equal to the specified ID.
        :param str since_id: Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available.
        :param str trim_user:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mentions_timeline_using_get_with_http_info(api_key, auth_token, ct0, **kwargs)  # noqa: E501
        else:
            (data) = self.mentions_timeline_using_get_with_http_info(api_key, auth_token, ct0, **kwargs)  # noqa: E501
            return data

    def mentions_timeline_using_get_with_http_info(self, api_key, auth_token, ct0, **kwargs):  # noqa: E501
        """get mentionsTimeline Detail  # noqa: E501

        See details  https://developer.twitter.com/en/docs/twitter-api/v1/tweets/timelines/api-reference/get-statuses-mentions_timeline  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mentions_timeline_using_get_with_http_info(api_key, auth_token, ct0, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str auth_token: (required)
        :param str ct0: (required)
        :param str include_entities:
        :param str max_id: Returns results with an ID less than (that is, older than) or equal to the specified ID.
        :param str since_id: Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available.
        :param str trim_user:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'auth_token', 'ct0', 'include_entities', 'max_id', 'since_id', 'trim_user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mentions_timeline_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `mentions_timeline_using_get`")  # noqa: E501
        # verify the required parameter 'auth_token' is set
        if self.api_client.client_side_validation and ('auth_token' not in params or
                                                       params['auth_token'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `auth_token` when calling `mentions_timeline_using_get`")  # noqa: E501
        # verify the required parameter 'ct0' is set
        if self.api_client.client_side_validation and ('ct0' not in params or
                                                       params['ct0'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ct0` when calling `mentions_timeline_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'auth_token' in params:
            query_params.append(('auth_token', params['auth_token']))  # noqa: E501
        if 'ct0' in params:
            query_params.append(('ct0', params['ct0']))  # noqa: E501
        if 'include_entities' in params:
            query_params.append(('include_entities', params['include_entities']))  # noqa: E501
        if 'max_id' in params:
            query_params.append(('maxId', params['max_id']))  # noqa: E501
        if 'since_id' in params:
            query_params.append(('sinceId', params['since_id']))  # noqa: E501
        if 'trim_user' in params:
            query_params.append(('trim_user', params['trim_user']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/mentionsTimeline', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mentions_timeline_using_post(self, api_key, auth_token, ct0, **kwargs):  # noqa: E501
        """get mentionsTimeline Detail  # noqa: E501

        See details  https://developer.twitter.com/en/docs/twitter-api/v1/tweets/timelines/api-reference/get-statuses-mentions_timeline  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mentions_timeline_using_post(api_key, auth_token, ct0, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str auth_token: (required)
        :param str ct0: (required)
        :param str include_entities:
        :param str max_id: Returns results with an ID less than (that is, older than) or equal to the specified ID.
        :param str since_id: Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available.
        :param str trim_user:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mentions_timeline_using_post_with_http_info(api_key, auth_token, ct0, **kwargs)  # noqa: E501
        else:
            (data) = self.mentions_timeline_using_post_with_http_info(api_key, auth_token, ct0, **kwargs)  # noqa: E501
            return data

    def mentions_timeline_using_post_with_http_info(self, api_key, auth_token, ct0, **kwargs):  # noqa: E501
        """get mentionsTimeline Detail  # noqa: E501

        See details  https://developer.twitter.com/en/docs/twitter-api/v1/tweets/timelines/api-reference/get-statuses-mentions_timeline  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mentions_timeline_using_post_with_http_info(api_key, auth_token, ct0, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str auth_token: (required)
        :param str ct0: (required)
        :param str include_entities:
        :param str max_id: Returns results with an ID less than (that is, older than) or equal to the specified ID.
        :param str since_id: Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available.
        :param str trim_user:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'auth_token', 'ct0', 'include_entities', 'max_id', 'since_id', 'trim_user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mentions_timeline_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `mentions_timeline_using_post`")  # noqa: E501
        # verify the required parameter 'auth_token' is set
        if self.api_client.client_side_validation and ('auth_token' not in params or
                                                       params['auth_token'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `auth_token` when calling `mentions_timeline_using_post`")  # noqa: E501
        # verify the required parameter 'ct0' is set
        if self.api_client.client_side_validation and ('ct0' not in params or
                                                       params['ct0'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ct0` when calling `mentions_timeline_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'auth_token' in params:
            query_params.append(('auth_token', params['auth_token']))  # noqa: E501
        if 'ct0' in params:
            query_params.append(('ct0', params['ct0']))  # noqa: E501
        if 'include_entities' in params:
            query_params.append(('include_entities', params['include_entities']))  # noqa: E501
        if 'max_id' in params:
            query_params.append(('maxId', params['max_id']))  # noqa: E501
        if 'since_id' in params:
            query_params.append(('sinceId', params['since_id']))  # noqa: E501
        if 'trim_user' in params:
            query_params.append(('trim_user', params['trim_user']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/mentionsTimeline', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def quotes_v2_using_get(self, api_key, tweet_id, **kwargs):  # noqa: E501
        """Quotes by V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotes_v2_using_get(api_key, tweet_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str tweet_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.quotes_v2_using_get_with_http_info(api_key, tweet_id, **kwargs)  # noqa: E501
        else:
            (data) = self.quotes_v2_using_get_with_http_info(api_key, tweet_id, **kwargs)  # noqa: E501
            return data

    def quotes_v2_using_get_with_http_info(self, api_key, tweet_id, **kwargs):  # noqa: E501
        """Quotes by V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotes_v2_using_get_with_http_info(api_key, tweet_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str tweet_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'tweet_id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method quotes_v2_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `quotes_v2_using_get`")  # noqa: E501
        # verify the required parameter 'tweet_id' is set
        if self.api_client.client_side_validation and ('tweet_id' not in params or
                                                       params['tweet_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `tweet_id` when calling `quotes_v2_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'tweet_id' in params:
            query_params.append(('tweetId', params['tweet_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/quotesV2', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def quotes_v2_using_post(self, api_key, tweet_id, **kwargs):  # noqa: E501
        """Quotes by V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotes_v2_using_post(api_key, tweet_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str tweet_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.quotes_v2_using_post_with_http_info(api_key, tweet_id, **kwargs)  # noqa: E501
        else:
            (data) = self.quotes_v2_using_post_with_http_info(api_key, tweet_id, **kwargs)  # noqa: E501
            return data

    def quotes_v2_using_post_with_http_info(self, api_key, tweet_id, **kwargs):  # noqa: E501
        """Quotes by V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotes_v2_using_post_with_http_info(api_key, tweet_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str tweet_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'tweet_id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method quotes_v2_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `quotes_v2_using_post`")  # noqa: E501
        # verify the required parameter 'tweet_id' is set
        if self.api_client.client_side_validation and ('tweet_id' not in params or
                                                       params['tweet_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `tweet_id` when calling `quotes_v2_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'tweet_id' in params:
            query_params.append(('tweetId', params['tweet_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/quotesV2', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retweeters_ids_using_get(self, api_key, id, **kwargs):  # noqa: E501
        """get retwweeters ids by tweetId  # noqa: E501

        Returns a collection of up to 100 user IDs belonging to users who have retweeted the Tweet specified by the id parameter. See details https://developer.twitter.com/en/docs/twitter-api/v1/tweets/post-and-engage/api-reference/get-statuses-retweeters-ids  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retweeters_ids_using_get(api_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retweeters_ids_using_get_with_http_info(api_key, id, **kwargs)  # noqa: E501
        else:
            (data) = self.retweeters_ids_using_get_with_http_info(api_key, id, **kwargs)  # noqa: E501
            return data

    def retweeters_ids_using_get_with_http_info(self, api_key, id, **kwargs):  # noqa: E501
        """get retwweeters ids by tweetId  # noqa: E501

        Returns a collection of up to 100 user IDs belonging to users who have retweeted the Tweet specified by the id parameter. See details https://developer.twitter.com/en/docs/twitter-api/v1/tweets/post-and-engage/api-reference/get-statuses-retweeters-ids  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retweeters_ids_using_get_with_http_info(api_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retweeters_ids_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `retweeters_ids_using_get`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `retweeters_ids_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/retweetersIds', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retweeters_ids_using_post(self, api_key, id, **kwargs):  # noqa: E501
        """get retwweeters ids by tweetId  # noqa: E501

        Returns a collection of up to 100 user IDs belonging to users who have retweeted the Tweet specified by the id parameter. See details https://developer.twitter.com/en/docs/twitter-api/v1/tweets/post-and-engage/api-reference/get-statuses-retweeters-ids  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retweeters_ids_using_post(api_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retweeters_ids_using_post_with_http_info(api_key, id, **kwargs)  # noqa: E501
        else:
            (data) = self.retweeters_ids_using_post_with_http_info(api_key, id, **kwargs)  # noqa: E501
            return data

    def retweeters_ids_using_post_with_http_info(self, api_key, id, **kwargs):  # noqa: E501
        """get retwweeters ids by tweetId  # noqa: E501

        Returns a collection of up to 100 user IDs belonging to users who have retweeted the Tweet specified by the id parameter. See details https://developer.twitter.com/en/docs/twitter-api/v1/tweets/post-and-engage/api-reference/get-statuses-retweeters-ids  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retweeters_ids_using_post_with_http_info(api_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retweeters_ids_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `retweeters_ids_using_post`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `retweeters_ids_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/retweetersIds', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retweeters_v2_using_get(self, api_key, tweet_id, **kwargs):  # noqa: E501
        """Retweeters by V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retweeters_v2_using_get(api_key, tweet_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str tweet_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retweeters_v2_using_get_with_http_info(api_key, tweet_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retweeters_v2_using_get_with_http_info(api_key, tweet_id, **kwargs)  # noqa: E501
            return data

    def retweeters_v2_using_get_with_http_info(self, api_key, tweet_id, **kwargs):  # noqa: E501
        """Retweeters by V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retweeters_v2_using_get_with_http_info(api_key, tweet_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str tweet_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'tweet_id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retweeters_v2_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `retweeters_v2_using_get`")  # noqa: E501
        # verify the required parameter 'tweet_id' is set
        if self.api_client.client_side_validation and ('tweet_id' not in params or
                                                       params['tweet_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `tweet_id` when calling `retweeters_v2_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'tweet_id' in params:
            query_params.append(('tweetId', params['tweet_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/retweetersV2', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retweeters_v2_using_post(self, api_key, tweet_id, **kwargs):  # noqa: E501
        """Retweeters by V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retweeters_v2_using_post(api_key, tweet_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str tweet_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retweeters_v2_using_post_with_http_info(api_key, tweet_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retweeters_v2_using_post_with_http_info(api_key, tweet_id, **kwargs)  # noqa: E501
            return data

    def retweeters_v2_using_post_with_http_info(self, api_key, tweet_id, **kwargs):  # noqa: E501
        """Retweeters by V2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retweeters_v2_using_post_with_http_info(api_key, tweet_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str tweet_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'tweet_id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retweeters_v2_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `retweeters_v2_using_post`")  # noqa: E501
        # verify the required parameter 'tweet_id' is set
        if self.api_client.client_side_validation and ('tweet_id' not in params or
                                                       params['tweet_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `tweet_id` when calling `retweeters_v2_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'tweet_id' in params:
            query_params.append(('tweetId', params['tweet_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/retweetersV2', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def tweet_simple_using_get(self, api_key, id, **kwargs):  # noqa: E501
        """tweet Brief information  # noqa: E501

        get tweet Brief information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tweet_simple_using_get(api_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.tweet_simple_using_get_with_http_info(api_key, id, **kwargs)  # noqa: E501
        else:
            (data) = self.tweet_simple_using_get_with_http_info(api_key, id, **kwargs)  # noqa: E501
            return data

    def tweet_simple_using_get_with_http_info(self, api_key, id, **kwargs):  # noqa: E501
        """tweet Brief information  # noqa: E501

        get tweet Brief information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tweet_simple_using_get_with_http_info(api_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tweet_simple_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `tweet_simple_using_get`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `tweet_simple_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/tweetSimple', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def tweet_simple_using_post(self, api_key, id, **kwargs):  # noqa: E501
        """tweet Brief information  # noqa: E501

        get tweet Brief information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tweet_simple_using_post(api_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.tweet_simple_using_post_with_http_info(api_key, id, **kwargs)  # noqa: E501
        else:
            (data) = self.tweet_simple_using_post_with_http_info(api_key, id, **kwargs)  # noqa: E501
            return data

    def tweet_simple_using_post_with_http_info(self, api_key, id, **kwargs):  # noqa: E501
        """tweet Brief information  # noqa: E501

        get tweet Brief information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tweet_simple_using_post_with_http_info(api_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tweet_simple_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `tweet_simple_using_post`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `tweet_simple_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/tweetSimple', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def tweet_timeline_using_get(self, api_key, id, **kwargs):  # noqa: E501
        """get TweetTimeline Detail  # noqa: E501

        get tweetDetail and reply  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tweet_timeline_using_get(api_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.tweet_timeline_using_get_with_http_info(api_key, id, **kwargs)  # noqa: E501
        else:
            (data) = self.tweet_timeline_using_get_with_http_info(api_key, id, **kwargs)  # noqa: E501
            return data

    def tweet_timeline_using_get_with_http_info(self, api_key, id, **kwargs):  # noqa: E501
        """get TweetTimeline Detail  # noqa: E501

        get tweetDetail and reply  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tweet_timeline_using_get_with_http_info(api_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tweet_timeline_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `tweet_timeline_using_get`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `tweet_timeline_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/tweetTimeline', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def tweet_timeline_using_post(self, api_key, id, **kwargs):  # noqa: E501
        """get TweetTimeline Detail  # noqa: E501

        get tweetDetail and reply  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tweet_timeline_using_post(api_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.tweet_timeline_using_post_with_http_info(api_key, id, **kwargs)  # noqa: E501
        else:
            (data) = self.tweet_timeline_using_post_with_http_info(api_key, id, **kwargs)  # noqa: E501
            return data

    def tweet_timeline_using_post_with_http_info(self, api_key, id, **kwargs):  # noqa: E501
        """get TweetTimeline Detail  # noqa: E501

        get tweetDetail and reply  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tweet_timeline_using_post_with_http_info(api_key, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tweet_timeline_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `tweet_timeline_using_post`")  # noqa: E501
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `tweet_timeline_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/tweetTimeline', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_tweet_reply_using_get(self, api_key, user_id, **kwargs):  # noqa: E501
        """get userTweetReply   # noqa: E501

        get user Tweet Reply  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_tweet_reply_using_get(api_key, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str user_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_tweet_reply_using_get_with_http_info(api_key, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_tweet_reply_using_get_with_http_info(api_key, user_id, **kwargs)  # noqa: E501
            return data

    def user_tweet_reply_using_get_with_http_info(self, api_key, user_id, **kwargs):  # noqa: E501
        """get userTweetReply   # noqa: E501

        get user Tweet Reply  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_tweet_reply_using_get_with_http_info(api_key, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str user_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'user_id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_tweet_reply_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `user_tweet_reply_using_get`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `user_tweet_reply_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/userTweetReply', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_tweet_reply_using_post(self, api_key, user_id, **kwargs):  # noqa: E501
        """get userTweetReply   # noqa: E501

        get user Tweet Reply  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_tweet_reply_using_post(api_key, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str user_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_tweet_reply_using_post_with_http_info(api_key, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_tweet_reply_using_post_with_http_info(api_key, user_id, **kwargs)  # noqa: E501
            return data

    def user_tweet_reply_using_post_with_http_info(self, api_key, user_id, **kwargs):  # noqa: E501
        """get userTweetReply   # noqa: E501

        get user Tweet Reply  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_tweet_reply_using_post_with_http_info(api_key, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param str user_id: (required)
        :param str cursor:
        :return: ResultT
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['api_key', 'user_id', 'cursor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_tweet_reply_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'api_key' is set
        if self.api_client.client_side_validation and ('api_key' not in params or
                                                       params['api_key'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `api_key` when calling `user_tweet_reply_using_post`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in params or
                                                       params['user_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `user_id` when calling `user_tweet_reply_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'api_key' in params:
            query_params.append(('apiKey', params['api_key']))  # noqa: E501
        if 'cursor' in params:
            query_params.append(('cursor', params['cursor']))  # noqa: E501
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/base/apitools/userTweetReply', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResultT',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
