<?php
/**
 * TwitterGetTweesApiToolsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Utools_twitter_tools_api
 *
 * X (Twitter) API for search, Tweets, users, followers, images, media and more. Supports some v1.1 and v2 API endpoints, with more to come in the future!
 *
 * OpenAPI spec version: 1.1
 * Contact: huojiecs@gmail.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.37
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * TwitterGetTweesApiToolsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TwitterGetTweesApiToolsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation favoritersV2UsingGET
     *
     * Favoriters by V2
     *
     * @param  string $api_key api_key (required)
     * @param  string $tweet_id tweet_id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function favoritersV2UsingGET($api_key, $tweet_id, $cursor = '-1')
    {
        list($response) = $this->favoritersV2UsingGETWithHttpInfo($api_key, $tweet_id, $cursor);
        return $response;
    }

    /**
     * Operation favoritersV2UsingGETWithHttpInfo
     *
     * Favoriters by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function favoritersV2UsingGETWithHttpInfo($api_key, $tweet_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->favoritersV2UsingGETRequest($api_key, $tweet_id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation favoritersV2UsingGETAsync
     *
     * Favoriters by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function favoritersV2UsingGETAsync($api_key, $tweet_id, $cursor = '-1')
    {
        return $this->favoritersV2UsingGETAsyncWithHttpInfo($api_key, $tweet_id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation favoritersV2UsingGETAsyncWithHttpInfo
     *
     * Favoriters by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function favoritersV2UsingGETAsyncWithHttpInfo($api_key, $tweet_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->favoritersV2UsingGETRequest($api_key, $tweet_id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'favoritersV2UsingGET'
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function favoritersV2UsingGETRequest($api_key, $tweet_id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling favoritersV2UsingGET'
            );
        }
        // verify the required parameter 'tweet_id' is set
        if ($tweet_id === null || (is_array($tweet_id) && count($tweet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tweet_id when calling favoritersV2UsingGET'
            );
        }

        $resourcePath = '/base/apitools/favoritersV2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($tweet_id !== null) {
            $queryParams['tweetId'] = ObjectSerializer::toQueryValue($tweet_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation favoritersV2UsingPOST
     *
     * Favoriters by V2
     *
     * @param  string $api_key api_key (required)
     * @param  string $tweet_id tweet_id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function favoritersV2UsingPOST($api_key, $tweet_id, $cursor = '-1')
    {
        list($response) = $this->favoritersV2UsingPOSTWithHttpInfo($api_key, $tweet_id, $cursor);
        return $response;
    }

    /**
     * Operation favoritersV2UsingPOSTWithHttpInfo
     *
     * Favoriters by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function favoritersV2UsingPOSTWithHttpInfo($api_key, $tweet_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->favoritersV2UsingPOSTRequest($api_key, $tweet_id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation favoritersV2UsingPOSTAsync
     *
     * Favoriters by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function favoritersV2UsingPOSTAsync($api_key, $tweet_id, $cursor = '-1')
    {
        return $this->favoritersV2UsingPOSTAsyncWithHttpInfo($api_key, $tweet_id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation favoritersV2UsingPOSTAsyncWithHttpInfo
     *
     * Favoriters by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function favoritersV2UsingPOSTAsyncWithHttpInfo($api_key, $tweet_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->favoritersV2UsingPOSTRequest($api_key, $tweet_id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'favoritersV2UsingPOST'
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function favoritersV2UsingPOSTRequest($api_key, $tweet_id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling favoritersV2UsingPOST'
            );
        }
        // verify the required parameter 'tweet_id' is set
        if ($tweet_id === null || (is_array($tweet_id) && count($tweet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tweet_id when calling favoritersV2UsingPOST'
            );
        }

        $resourcePath = '/base/apitools/favoritersV2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($tweet_id !== null) {
            $queryParams['tweetId'] = ObjectSerializer::toQueryValue($tweet_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation favoritesListUsingGET
     *
     * favorites are now known as likes.
     *
     * @param  string $api_key api_key (required)
     * @param  string $user_id user_id (required)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $screen_name screen_name (optional, default to elonmusk)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function favoritesListUsingGET($api_key, $user_id, $max_id = null, $screen_name = 'elonmusk', $since_id = null)
    {
        list($response) = $this->favoritesListUsingGETWithHttpInfo($api_key, $user_id, $max_id, $screen_name, $since_id);
        return $response;
    }

    /**
     * Operation favoritesListUsingGETWithHttpInfo
     *
     * favorites are now known as likes.
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $screen_name (optional, default to elonmusk)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function favoritesListUsingGETWithHttpInfo($api_key, $user_id, $max_id = null, $screen_name = 'elonmusk', $since_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->favoritesListUsingGETRequest($api_key, $user_id, $max_id, $screen_name, $since_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation favoritesListUsingGETAsync
     *
     * favorites are now known as likes.
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $screen_name (optional, default to elonmusk)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function favoritesListUsingGETAsync($api_key, $user_id, $max_id = null, $screen_name = 'elonmusk', $since_id = null)
    {
        return $this->favoritesListUsingGETAsyncWithHttpInfo($api_key, $user_id, $max_id, $screen_name, $since_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation favoritesListUsingGETAsyncWithHttpInfo
     *
     * favorites are now known as likes.
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $screen_name (optional, default to elonmusk)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function favoritesListUsingGETAsyncWithHttpInfo($api_key, $user_id, $max_id = null, $screen_name = 'elonmusk', $since_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->favoritesListUsingGETRequest($api_key, $user_id, $max_id, $screen_name, $since_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'favoritesListUsingGET'
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $screen_name (optional, default to elonmusk)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function favoritesListUsingGETRequest($api_key, $user_id, $max_id = null, $screen_name = 'elonmusk', $since_id = null)
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling favoritesListUsingGET'
            );
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling favoritesListUsingGET'
            );
        }

        $resourcePath = '/base/apitools/favoritesList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($max_id !== null) {
            $queryParams['maxId'] = ObjectSerializer::toQueryValue($max_id);
        }
        // query params
        if ($screen_name !== null) {
            $queryParams['screenName'] = ObjectSerializer::toQueryValue($screen_name);
        }
        // query params
        if ($since_id !== null) {
            $queryParams['sinceId'] = ObjectSerializer::toQueryValue($since_id);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation favoritesListUsingPOST
     *
     * favorites are now known as likes.
     *
     * @param  string $api_key api_key (required)
     * @param  string $user_id user_id (required)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $screen_name screen_name (optional, default to elonmusk)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function favoritesListUsingPOST($api_key, $user_id, $max_id = null, $screen_name = 'elonmusk', $since_id = null)
    {
        list($response) = $this->favoritesListUsingPOSTWithHttpInfo($api_key, $user_id, $max_id, $screen_name, $since_id);
        return $response;
    }

    /**
     * Operation favoritesListUsingPOSTWithHttpInfo
     *
     * favorites are now known as likes.
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $screen_name (optional, default to elonmusk)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function favoritesListUsingPOSTWithHttpInfo($api_key, $user_id, $max_id = null, $screen_name = 'elonmusk', $since_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->favoritesListUsingPOSTRequest($api_key, $user_id, $max_id, $screen_name, $since_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation favoritesListUsingPOSTAsync
     *
     * favorites are now known as likes.
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $screen_name (optional, default to elonmusk)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function favoritesListUsingPOSTAsync($api_key, $user_id, $max_id = null, $screen_name = 'elonmusk', $since_id = null)
    {
        return $this->favoritesListUsingPOSTAsyncWithHttpInfo($api_key, $user_id, $max_id, $screen_name, $since_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation favoritesListUsingPOSTAsyncWithHttpInfo
     *
     * favorites are now known as likes.
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $screen_name (optional, default to elonmusk)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function favoritesListUsingPOSTAsyncWithHttpInfo($api_key, $user_id, $max_id = null, $screen_name = 'elonmusk', $since_id = null)
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->favoritesListUsingPOSTRequest($api_key, $user_id, $max_id, $screen_name, $since_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'favoritesListUsingPOST'
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $screen_name (optional, default to elonmusk)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function favoritesListUsingPOSTRequest($api_key, $user_id, $max_id = null, $screen_name = 'elonmusk', $since_id = null)
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling favoritesListUsingPOST'
            );
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling favoritesListUsingPOST'
            );
        }

        $resourcePath = '/base/apitools/favoritesList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($max_id !== null) {
            $queryParams['maxId'] = ObjectSerializer::toQueryValue($max_id);
        }
        // query params
        if ($screen_name !== null) {
            $queryParams['screenName'] = ObjectSerializer::toQueryValue($screen_name);
        }
        // query params
        if ($since_id !== null) {
            $queryParams['sinceId'] = ObjectSerializer::toQueryValue($since_id);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mentionsTimelineUsingGET
     *
     * get mentionsTimeline Detail
     *
     * @param  string $api_key api_key (required)
     * @param  string $auth_token auth_token (required)
     * @param  string $ct0 ct0 (required)
     * @param  string $include_entities include_entities (optional, default to false)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     * @param  string $trim_user trim_user (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function mentionsTimelineUsingGET($api_key, $auth_token, $ct0, $include_entities = 'false', $max_id = null, $since_id = null, $trim_user = 'true')
    {
        list($response) = $this->mentionsTimelineUsingGETWithHttpInfo($api_key, $auth_token, $ct0, $include_entities, $max_id, $since_id, $trim_user);
        return $response;
    }

    /**
     * Operation mentionsTimelineUsingGETWithHttpInfo
     *
     * get mentionsTimeline Detail
     *
     * @param  string $api_key (required)
     * @param  string $auth_token (required)
     * @param  string $ct0 (required)
     * @param  string $include_entities (optional, default to false)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     * @param  string $trim_user (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function mentionsTimelineUsingGETWithHttpInfo($api_key, $auth_token, $ct0, $include_entities = 'false', $max_id = null, $since_id = null, $trim_user = 'true')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->mentionsTimelineUsingGETRequest($api_key, $auth_token, $ct0, $include_entities, $max_id, $since_id, $trim_user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mentionsTimelineUsingGETAsync
     *
     * get mentionsTimeline Detail
     *
     * @param  string $api_key (required)
     * @param  string $auth_token (required)
     * @param  string $ct0 (required)
     * @param  string $include_entities (optional, default to false)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     * @param  string $trim_user (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mentionsTimelineUsingGETAsync($api_key, $auth_token, $ct0, $include_entities = 'false', $max_id = null, $since_id = null, $trim_user = 'true')
    {
        return $this->mentionsTimelineUsingGETAsyncWithHttpInfo($api_key, $auth_token, $ct0, $include_entities, $max_id, $since_id, $trim_user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mentionsTimelineUsingGETAsyncWithHttpInfo
     *
     * get mentionsTimeline Detail
     *
     * @param  string $api_key (required)
     * @param  string $auth_token (required)
     * @param  string $ct0 (required)
     * @param  string $include_entities (optional, default to false)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     * @param  string $trim_user (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mentionsTimelineUsingGETAsyncWithHttpInfo($api_key, $auth_token, $ct0, $include_entities = 'false', $max_id = null, $since_id = null, $trim_user = 'true')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->mentionsTimelineUsingGETRequest($api_key, $auth_token, $ct0, $include_entities, $max_id, $since_id, $trim_user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mentionsTimelineUsingGET'
     *
     * @param  string $api_key (required)
     * @param  string $auth_token (required)
     * @param  string $ct0 (required)
     * @param  string $include_entities (optional, default to false)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     * @param  string $trim_user (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function mentionsTimelineUsingGETRequest($api_key, $auth_token, $ct0, $include_entities = 'false', $max_id = null, $since_id = null, $trim_user = 'true')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling mentionsTimelineUsingGET'
            );
        }
        // verify the required parameter 'auth_token' is set
        if ($auth_token === null || (is_array($auth_token) && count($auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $auth_token when calling mentionsTimelineUsingGET'
            );
        }
        // verify the required parameter 'ct0' is set
        if ($ct0 === null || (is_array($ct0) && count($ct0) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ct0 when calling mentionsTimelineUsingGET'
            );
        }

        $resourcePath = '/base/apitools/mentionsTimeline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($auth_token !== null) {
            $queryParams['auth_token'] = ObjectSerializer::toQueryValue($auth_token);
        }
        // query params
        if ($ct0 !== null) {
            $queryParams['ct0'] = ObjectSerializer::toQueryValue($ct0);
        }
        // query params
        if ($include_entities !== null) {
            $queryParams['include_entities'] = ObjectSerializer::toQueryValue($include_entities);
        }
        // query params
        if ($max_id !== null) {
            $queryParams['maxId'] = ObjectSerializer::toQueryValue($max_id);
        }
        // query params
        if ($since_id !== null) {
            $queryParams['sinceId'] = ObjectSerializer::toQueryValue($since_id);
        }
        // query params
        if ($trim_user !== null) {
            $queryParams['trim_user'] = ObjectSerializer::toQueryValue($trim_user);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mentionsTimelineUsingPOST
     *
     * get mentionsTimeline Detail
     *
     * @param  string $api_key api_key (required)
     * @param  string $auth_token auth_token (required)
     * @param  string $ct0 ct0 (required)
     * @param  string $include_entities include_entities (optional, default to false)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     * @param  string $trim_user trim_user (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function mentionsTimelineUsingPOST($api_key, $auth_token, $ct0, $include_entities = 'false', $max_id = null, $since_id = null, $trim_user = 'true')
    {
        list($response) = $this->mentionsTimelineUsingPOSTWithHttpInfo($api_key, $auth_token, $ct0, $include_entities, $max_id, $since_id, $trim_user);
        return $response;
    }

    /**
     * Operation mentionsTimelineUsingPOSTWithHttpInfo
     *
     * get mentionsTimeline Detail
     *
     * @param  string $api_key (required)
     * @param  string $auth_token (required)
     * @param  string $ct0 (required)
     * @param  string $include_entities (optional, default to false)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     * @param  string $trim_user (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function mentionsTimelineUsingPOSTWithHttpInfo($api_key, $auth_token, $ct0, $include_entities = 'false', $max_id = null, $since_id = null, $trim_user = 'true')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->mentionsTimelineUsingPOSTRequest($api_key, $auth_token, $ct0, $include_entities, $max_id, $since_id, $trim_user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mentionsTimelineUsingPOSTAsync
     *
     * get mentionsTimeline Detail
     *
     * @param  string $api_key (required)
     * @param  string $auth_token (required)
     * @param  string $ct0 (required)
     * @param  string $include_entities (optional, default to false)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     * @param  string $trim_user (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mentionsTimelineUsingPOSTAsync($api_key, $auth_token, $ct0, $include_entities = 'false', $max_id = null, $since_id = null, $trim_user = 'true')
    {
        return $this->mentionsTimelineUsingPOSTAsyncWithHttpInfo($api_key, $auth_token, $ct0, $include_entities, $max_id, $since_id, $trim_user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mentionsTimelineUsingPOSTAsyncWithHttpInfo
     *
     * get mentionsTimeline Detail
     *
     * @param  string $api_key (required)
     * @param  string $auth_token (required)
     * @param  string $ct0 (required)
     * @param  string $include_entities (optional, default to false)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     * @param  string $trim_user (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mentionsTimelineUsingPOSTAsyncWithHttpInfo($api_key, $auth_token, $ct0, $include_entities = 'false', $max_id = null, $since_id = null, $trim_user = 'true')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->mentionsTimelineUsingPOSTRequest($api_key, $auth_token, $ct0, $include_entities, $max_id, $since_id, $trim_user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mentionsTimelineUsingPOST'
     *
     * @param  string $api_key (required)
     * @param  string $auth_token (required)
     * @param  string $ct0 (required)
     * @param  string $include_entities (optional, default to false)
     * @param  string $max_id Returns results with an ID less than (that is, older than) or equal to the specified ID. (optional)
     * @param  string $since_id Returns results with an ID greater than (that is, more recent than) the specified ID. There are limits to the number of Tweets which can be accessed through the API. If the limit of Tweets has occured since the since_id, the since_id will be forced to the oldest ID available. (optional)
     * @param  string $trim_user (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function mentionsTimelineUsingPOSTRequest($api_key, $auth_token, $ct0, $include_entities = 'false', $max_id = null, $since_id = null, $trim_user = 'true')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling mentionsTimelineUsingPOST'
            );
        }
        // verify the required parameter 'auth_token' is set
        if ($auth_token === null || (is_array($auth_token) && count($auth_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $auth_token when calling mentionsTimelineUsingPOST'
            );
        }
        // verify the required parameter 'ct0' is set
        if ($ct0 === null || (is_array($ct0) && count($ct0) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ct0 when calling mentionsTimelineUsingPOST'
            );
        }

        $resourcePath = '/base/apitools/mentionsTimeline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($auth_token !== null) {
            $queryParams['auth_token'] = ObjectSerializer::toQueryValue($auth_token);
        }
        // query params
        if ($ct0 !== null) {
            $queryParams['ct0'] = ObjectSerializer::toQueryValue($ct0);
        }
        // query params
        if ($include_entities !== null) {
            $queryParams['include_entities'] = ObjectSerializer::toQueryValue($include_entities);
        }
        // query params
        if ($max_id !== null) {
            $queryParams['maxId'] = ObjectSerializer::toQueryValue($max_id);
        }
        // query params
        if ($since_id !== null) {
            $queryParams['sinceId'] = ObjectSerializer::toQueryValue($since_id);
        }
        // query params
        if ($trim_user !== null) {
            $queryParams['trim_user'] = ObjectSerializer::toQueryValue($trim_user);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quotesV2UsingGET
     *
     * Quotes by V2
     *
     * @param  string $api_key api_key (required)
     * @param  string $tweet_id tweet_id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function quotesV2UsingGET($api_key, $tweet_id, $cursor = '-1')
    {
        list($response) = $this->quotesV2UsingGETWithHttpInfo($api_key, $tweet_id, $cursor);
        return $response;
    }

    /**
     * Operation quotesV2UsingGETWithHttpInfo
     *
     * Quotes by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function quotesV2UsingGETWithHttpInfo($api_key, $tweet_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->quotesV2UsingGETRequest($api_key, $tweet_id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation quotesV2UsingGETAsync
     *
     * Quotes by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quotesV2UsingGETAsync($api_key, $tweet_id, $cursor = '-1')
    {
        return $this->quotesV2UsingGETAsyncWithHttpInfo($api_key, $tweet_id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quotesV2UsingGETAsyncWithHttpInfo
     *
     * Quotes by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quotesV2UsingGETAsyncWithHttpInfo($api_key, $tweet_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->quotesV2UsingGETRequest($api_key, $tweet_id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quotesV2UsingGET'
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function quotesV2UsingGETRequest($api_key, $tweet_id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling quotesV2UsingGET'
            );
        }
        // verify the required parameter 'tweet_id' is set
        if ($tweet_id === null || (is_array($tweet_id) && count($tweet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tweet_id when calling quotesV2UsingGET'
            );
        }

        $resourcePath = '/base/apitools/quotesV2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($tweet_id !== null) {
            $queryParams['tweetId'] = ObjectSerializer::toQueryValue($tweet_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quotesV2UsingPOST
     *
     * Quotes by V2
     *
     * @param  string $api_key api_key (required)
     * @param  string $tweet_id tweet_id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function quotesV2UsingPOST($api_key, $tweet_id, $cursor = '-1')
    {
        list($response) = $this->quotesV2UsingPOSTWithHttpInfo($api_key, $tweet_id, $cursor);
        return $response;
    }

    /**
     * Operation quotesV2UsingPOSTWithHttpInfo
     *
     * Quotes by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function quotesV2UsingPOSTWithHttpInfo($api_key, $tweet_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->quotesV2UsingPOSTRequest($api_key, $tweet_id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation quotesV2UsingPOSTAsync
     *
     * Quotes by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quotesV2UsingPOSTAsync($api_key, $tweet_id, $cursor = '-1')
    {
        return $this->quotesV2UsingPOSTAsyncWithHttpInfo($api_key, $tweet_id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quotesV2UsingPOSTAsyncWithHttpInfo
     *
     * Quotes by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quotesV2UsingPOSTAsyncWithHttpInfo($api_key, $tweet_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->quotesV2UsingPOSTRequest($api_key, $tweet_id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quotesV2UsingPOST'
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function quotesV2UsingPOSTRequest($api_key, $tweet_id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling quotesV2UsingPOST'
            );
        }
        // verify the required parameter 'tweet_id' is set
        if ($tweet_id === null || (is_array($tweet_id) && count($tweet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tweet_id when calling quotesV2UsingPOST'
            );
        }

        $resourcePath = '/base/apitools/quotesV2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($tweet_id !== null) {
            $queryParams['tweetId'] = ObjectSerializer::toQueryValue($tweet_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retweetersIdsUsingGET
     *
     * get retwweeters ids by tweetId
     *
     * @param  string $api_key api_key (required)
     * @param  string $id id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function retweetersIdsUsingGET($api_key, $id, $cursor = '-1')
    {
        list($response) = $this->retweetersIdsUsingGETWithHttpInfo($api_key, $id, $cursor);
        return $response;
    }

    /**
     * Operation retweetersIdsUsingGETWithHttpInfo
     *
     * get retwweeters ids by tweetId
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function retweetersIdsUsingGETWithHttpInfo($api_key, $id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->retweetersIdsUsingGETRequest($api_key, $id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation retweetersIdsUsingGETAsync
     *
     * get retwweeters ids by tweetId
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retweetersIdsUsingGETAsync($api_key, $id, $cursor = '-1')
    {
        return $this->retweetersIdsUsingGETAsyncWithHttpInfo($api_key, $id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retweetersIdsUsingGETAsyncWithHttpInfo
     *
     * get retwweeters ids by tweetId
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retweetersIdsUsingGETAsyncWithHttpInfo($api_key, $id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->retweetersIdsUsingGETRequest($api_key, $id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retweetersIdsUsingGET'
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function retweetersIdsUsingGETRequest($api_key, $id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling retweetersIdsUsingGET'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling retweetersIdsUsingGET'
            );
        }

        $resourcePath = '/base/apitools/retweetersIds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retweetersIdsUsingPOST
     *
     * get retwweeters ids by tweetId
     *
     * @param  string $api_key api_key (required)
     * @param  string $id id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function retweetersIdsUsingPOST($api_key, $id, $cursor = '-1')
    {
        list($response) = $this->retweetersIdsUsingPOSTWithHttpInfo($api_key, $id, $cursor);
        return $response;
    }

    /**
     * Operation retweetersIdsUsingPOSTWithHttpInfo
     *
     * get retwweeters ids by tweetId
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function retweetersIdsUsingPOSTWithHttpInfo($api_key, $id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->retweetersIdsUsingPOSTRequest($api_key, $id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation retweetersIdsUsingPOSTAsync
     *
     * get retwweeters ids by tweetId
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retweetersIdsUsingPOSTAsync($api_key, $id, $cursor = '-1')
    {
        return $this->retweetersIdsUsingPOSTAsyncWithHttpInfo($api_key, $id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retweetersIdsUsingPOSTAsyncWithHttpInfo
     *
     * get retwweeters ids by tweetId
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retweetersIdsUsingPOSTAsyncWithHttpInfo($api_key, $id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->retweetersIdsUsingPOSTRequest($api_key, $id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retweetersIdsUsingPOST'
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function retweetersIdsUsingPOSTRequest($api_key, $id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling retweetersIdsUsingPOST'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling retweetersIdsUsingPOST'
            );
        }

        $resourcePath = '/base/apitools/retweetersIds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retweetersV2UsingGET
     *
     * Retweeters by V2
     *
     * @param  string $api_key api_key (required)
     * @param  string $tweet_id tweet_id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function retweetersV2UsingGET($api_key, $tweet_id, $cursor = '-1')
    {
        list($response) = $this->retweetersV2UsingGETWithHttpInfo($api_key, $tweet_id, $cursor);
        return $response;
    }

    /**
     * Operation retweetersV2UsingGETWithHttpInfo
     *
     * Retweeters by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function retweetersV2UsingGETWithHttpInfo($api_key, $tweet_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->retweetersV2UsingGETRequest($api_key, $tweet_id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation retweetersV2UsingGETAsync
     *
     * Retweeters by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retweetersV2UsingGETAsync($api_key, $tweet_id, $cursor = '-1')
    {
        return $this->retweetersV2UsingGETAsyncWithHttpInfo($api_key, $tweet_id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retweetersV2UsingGETAsyncWithHttpInfo
     *
     * Retweeters by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retweetersV2UsingGETAsyncWithHttpInfo($api_key, $tweet_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->retweetersV2UsingGETRequest($api_key, $tweet_id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retweetersV2UsingGET'
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function retweetersV2UsingGETRequest($api_key, $tweet_id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling retweetersV2UsingGET'
            );
        }
        // verify the required parameter 'tweet_id' is set
        if ($tweet_id === null || (is_array($tweet_id) && count($tweet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tweet_id when calling retweetersV2UsingGET'
            );
        }

        $resourcePath = '/base/apitools/retweetersV2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($tweet_id !== null) {
            $queryParams['tweetId'] = ObjectSerializer::toQueryValue($tweet_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retweetersV2UsingPOST
     *
     * Retweeters by V2
     *
     * @param  string $api_key api_key (required)
     * @param  string $tweet_id tweet_id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function retweetersV2UsingPOST($api_key, $tweet_id, $cursor = '-1')
    {
        list($response) = $this->retweetersV2UsingPOSTWithHttpInfo($api_key, $tweet_id, $cursor);
        return $response;
    }

    /**
     * Operation retweetersV2UsingPOSTWithHttpInfo
     *
     * Retweeters by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function retweetersV2UsingPOSTWithHttpInfo($api_key, $tweet_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->retweetersV2UsingPOSTRequest($api_key, $tweet_id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation retweetersV2UsingPOSTAsync
     *
     * Retweeters by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retweetersV2UsingPOSTAsync($api_key, $tweet_id, $cursor = '-1')
    {
        return $this->retweetersV2UsingPOSTAsyncWithHttpInfo($api_key, $tweet_id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retweetersV2UsingPOSTAsyncWithHttpInfo
     *
     * Retweeters by V2
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retweetersV2UsingPOSTAsyncWithHttpInfo($api_key, $tweet_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->retweetersV2UsingPOSTRequest($api_key, $tweet_id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retweetersV2UsingPOST'
     *
     * @param  string $api_key (required)
     * @param  string $tweet_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function retweetersV2UsingPOSTRequest($api_key, $tweet_id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling retweetersV2UsingPOST'
            );
        }
        // verify the required parameter 'tweet_id' is set
        if ($tweet_id === null || (is_array($tweet_id) && count($tweet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tweet_id when calling retweetersV2UsingPOST'
            );
        }

        $resourcePath = '/base/apitools/retweetersV2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($tweet_id !== null) {
            $queryParams['tweetId'] = ObjectSerializer::toQueryValue($tweet_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tweetSimpleUsingGET
     *
     * tweet Brief information
     *
     * @param  string $api_key api_key (required)
     * @param  string $id id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function tweetSimpleUsingGET($api_key, $id, $cursor = '-1')
    {
        list($response) = $this->tweetSimpleUsingGETWithHttpInfo($api_key, $id, $cursor);
        return $response;
    }

    /**
     * Operation tweetSimpleUsingGETWithHttpInfo
     *
     * tweet Brief information
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function tweetSimpleUsingGETWithHttpInfo($api_key, $id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->tweetSimpleUsingGETRequest($api_key, $id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tweetSimpleUsingGETAsync
     *
     * tweet Brief information
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetSimpleUsingGETAsync($api_key, $id, $cursor = '-1')
    {
        return $this->tweetSimpleUsingGETAsyncWithHttpInfo($api_key, $id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tweetSimpleUsingGETAsyncWithHttpInfo
     *
     * tweet Brief information
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetSimpleUsingGETAsyncWithHttpInfo($api_key, $id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->tweetSimpleUsingGETRequest($api_key, $id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tweetSimpleUsingGET'
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tweetSimpleUsingGETRequest($api_key, $id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling tweetSimpleUsingGET'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tweetSimpleUsingGET'
            );
        }

        $resourcePath = '/base/apitools/tweetSimple';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tweetSimpleUsingPOST
     *
     * tweet Brief information
     *
     * @param  string $api_key api_key (required)
     * @param  string $id id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function tweetSimpleUsingPOST($api_key, $id, $cursor = '-1')
    {
        list($response) = $this->tweetSimpleUsingPOSTWithHttpInfo($api_key, $id, $cursor);
        return $response;
    }

    /**
     * Operation tweetSimpleUsingPOSTWithHttpInfo
     *
     * tweet Brief information
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function tweetSimpleUsingPOSTWithHttpInfo($api_key, $id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->tweetSimpleUsingPOSTRequest($api_key, $id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tweetSimpleUsingPOSTAsync
     *
     * tweet Brief information
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetSimpleUsingPOSTAsync($api_key, $id, $cursor = '-1')
    {
        return $this->tweetSimpleUsingPOSTAsyncWithHttpInfo($api_key, $id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tweetSimpleUsingPOSTAsyncWithHttpInfo
     *
     * tweet Brief information
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetSimpleUsingPOSTAsyncWithHttpInfo($api_key, $id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->tweetSimpleUsingPOSTRequest($api_key, $id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tweetSimpleUsingPOST'
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tweetSimpleUsingPOSTRequest($api_key, $id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling tweetSimpleUsingPOST'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tweetSimpleUsingPOST'
            );
        }

        $resourcePath = '/base/apitools/tweetSimple';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tweetTimelineUsingGET
     *
     * get TweetTimeline Detail
     *
     * @param  string $api_key api_key (required)
     * @param  string $id id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function tweetTimelineUsingGET($api_key, $id, $cursor = '-1')
    {
        list($response) = $this->tweetTimelineUsingGETWithHttpInfo($api_key, $id, $cursor);
        return $response;
    }

    /**
     * Operation tweetTimelineUsingGETWithHttpInfo
     *
     * get TweetTimeline Detail
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function tweetTimelineUsingGETWithHttpInfo($api_key, $id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->tweetTimelineUsingGETRequest($api_key, $id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tweetTimelineUsingGETAsync
     *
     * get TweetTimeline Detail
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetTimelineUsingGETAsync($api_key, $id, $cursor = '-1')
    {
        return $this->tweetTimelineUsingGETAsyncWithHttpInfo($api_key, $id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tweetTimelineUsingGETAsyncWithHttpInfo
     *
     * get TweetTimeline Detail
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetTimelineUsingGETAsyncWithHttpInfo($api_key, $id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->tweetTimelineUsingGETRequest($api_key, $id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tweetTimelineUsingGET'
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tweetTimelineUsingGETRequest($api_key, $id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling tweetTimelineUsingGET'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tweetTimelineUsingGET'
            );
        }

        $resourcePath = '/base/apitools/tweetTimeline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tweetTimelineUsingPOST
     *
     * get TweetTimeline Detail
     *
     * @param  string $api_key api_key (required)
     * @param  string $id id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function tweetTimelineUsingPOST($api_key, $id, $cursor = '-1')
    {
        list($response) = $this->tweetTimelineUsingPOSTWithHttpInfo($api_key, $id, $cursor);
        return $response;
    }

    /**
     * Operation tweetTimelineUsingPOSTWithHttpInfo
     *
     * get TweetTimeline Detail
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function tweetTimelineUsingPOSTWithHttpInfo($api_key, $id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->tweetTimelineUsingPOSTRequest($api_key, $id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tweetTimelineUsingPOSTAsync
     *
     * get TweetTimeline Detail
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetTimelineUsingPOSTAsync($api_key, $id, $cursor = '-1')
    {
        return $this->tweetTimelineUsingPOSTAsyncWithHttpInfo($api_key, $id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tweetTimelineUsingPOSTAsyncWithHttpInfo
     *
     * get TweetTimeline Detail
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetTimelineUsingPOSTAsyncWithHttpInfo($api_key, $id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->tweetTimelineUsingPOSTRequest($api_key, $id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tweetTimelineUsingPOST'
     *
     * @param  string $api_key (required)
     * @param  string $id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tweetTimelineUsingPOSTRequest($api_key, $id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling tweetTimelineUsingPOST'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tweetTimelineUsingPOST'
            );
        }

        $resourcePath = '/base/apitools/tweetTimeline';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userTweetReplyUsingGET
     *
     * get userTweetReply
     *
     * @param  string $api_key api_key (required)
     * @param  string $user_id user_id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function userTweetReplyUsingGET($api_key, $user_id, $cursor = '-1')
    {
        list($response) = $this->userTweetReplyUsingGETWithHttpInfo($api_key, $user_id, $cursor);
        return $response;
    }

    /**
     * Operation userTweetReplyUsingGETWithHttpInfo
     *
     * get userTweetReply
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function userTweetReplyUsingGETWithHttpInfo($api_key, $user_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->userTweetReplyUsingGETRequest($api_key, $user_id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation userTweetReplyUsingGETAsync
     *
     * get userTweetReply
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userTweetReplyUsingGETAsync($api_key, $user_id, $cursor = '-1')
    {
        return $this->userTweetReplyUsingGETAsyncWithHttpInfo($api_key, $user_id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userTweetReplyUsingGETAsyncWithHttpInfo
     *
     * get userTweetReply
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userTweetReplyUsingGETAsyncWithHttpInfo($api_key, $user_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->userTweetReplyUsingGETRequest($api_key, $user_id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userTweetReplyUsingGET'
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function userTweetReplyUsingGETRequest($api_key, $user_id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling userTweetReplyUsingGET'
            );
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling userTweetReplyUsingGET'
            );
        }

        $resourcePath = '/base/apitools/userTweetReply';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userTweetReplyUsingPOST
     *
     * get userTweetReply
     *
     * @param  string $api_key api_key (required)
     * @param  string $user_id user_id (required)
     * @param  string $cursor cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResultT
     */
    public function userTweetReplyUsingPOST($api_key, $user_id, $cursor = '-1')
    {
        list($response) = $this->userTweetReplyUsingPOSTWithHttpInfo($api_key, $user_id, $cursor);
        return $response;
    }

    /**
     * Operation userTweetReplyUsingPOSTWithHttpInfo
     *
     * get userTweetReply
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResultT, HTTP status code, HTTP response headers (array of strings)
     */
    public function userTweetReplyUsingPOSTWithHttpInfo($api_key, $user_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->userTweetReplyUsingPOSTRequest($api_key, $user_id, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResultT',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation userTweetReplyUsingPOSTAsync
     *
     * get userTweetReply
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userTweetReplyUsingPOSTAsync($api_key, $user_id, $cursor = '-1')
    {
        return $this->userTweetReplyUsingPOSTAsyncWithHttpInfo($api_key, $user_id, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userTweetReplyUsingPOSTAsyncWithHttpInfo
     *
     * get userTweetReply
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userTweetReplyUsingPOSTAsyncWithHttpInfo($api_key, $user_id, $cursor = '-1')
    {
        $returnType = '\Swagger\Client\Model\ResultT';
        $request = $this->userTweetReplyUsingPOSTRequest($api_key, $user_id, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userTweetReplyUsingPOST'
     *
     * @param  string $api_key (required)
     * @param  string $user_id (required)
     * @param  string $cursor (optional, default to -1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function userTweetReplyUsingPOSTRequest($api_key, $user_id, $cursor = '-1')
    {
        // verify the required parameter 'api_key' is set
        if ($api_key === null || (is_array($api_key) && count($api_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_key when calling userTweetReplyUsingPOST'
            );
        }
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling userTweetReplyUsingPOST'
            );
        }

        $resourcePath = '/base/apitools/userTweetReply';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($api_key !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($api_key);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
